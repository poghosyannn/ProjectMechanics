package CirclePacking;

import org.opensourcephysics.display.*;
import org.opensourcephysics.frames.DisplayFrame;

import java.awt.*;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.Random;

public class PackingSimulator implements Drawable {
    static class Particle {
        double x, y;
        double vx = 0, vy = 0;
        double ax = 0, ay = 0;
        double radius;
        double mass = 1.0;

        Particle(double x, double y, double radius) {
            this.x = x;
            this.y = y;
            this.vx = 0;
            this.vy = 0;
            this.ax = 0;
            this.ay = 0;
            this.radius = radius;
            this.mass = Math.PI * radius * radius;
        }
    }

    // Simulation parameters
    final int N = 8;
    final double dt = 0.04;
    final int T = 1000;
    final double A = 180; // Attractive force constant
    final double B = 250000;// Repulsive force constant
    final double drag = 0.5; // Air resistance
    final double BOX_WIDTH = 2000;
    final double BOX_HEIGHT = 2000;
    final double MIN_RADIUS = 1;
    final double MAX_RADIUS = 4;

    Particle[] particles = new Particle[N];
    DisplayFrame frame = new DisplayFrame("x", "y", "Packing Circles");

    public void initialize() {
        Random rand = new Random();

        for (int i = 0; i < N; i++) {
            double radius = MIN_RADIUS + (MAX_RADIUS - MIN_RADIUS) * rand.nextDouble();
            double x = radius + (BOX_WIDTH - 2 * radius) * rand.nextDouble();
            double y = radius + (BOX_HEIGHT - 2 * radius) * rand.nextDouble();
            particles[i] = new Particle(x, y, radius);
        }

        frame.setPreferredMinMax(0, BOX_WIDTH, 0, BOX_HEIGHT);
        frame.setDefaultCloseOperation(javax.swing.JFrame.EXIT_ON_CLOSE);
        frame.addDrawable(this);
        frame.setVisible(true);
    }

    public void runSimulation() {
        for (int t = 0; t < T; t++) {
            computeForces();
            verletIntegration();
            frame.render();
            pause(1000);
        }

        // After simulation is complete, log final results
        double[] boundingBox = computeBoundingBox();
        double potentialEnergy = computePotentialEnergy();
        
        PrintWriter writer = null;
        try {
            writer = new PrintWriter("src/CirclePacking/log_mass_run2.txt");
            writer.printf("Parameters: A=%.0f, B=%.0f, drag=%.2f, dt=%.2f%n", A, B, drag, dt);
            writer.printf("Bounding box: width=%.2f, height=%.2f, area=%.2f%n",
                          boundingBox[4], boundingBox[5], boundingBox[6]);
            writer.printf("Total potential energy: %.2f%n", potentialEnergy);
            writer.println("Final particle positions:");

            for (int i = 0; i < N; i++) {
                Particle p = particles[i];
                writer.printf("Particle %d: x=%.2f, y=%.2f, r=%.2f, mass=%.2f%n",
                        i, p.x, p.y, p.radius, p.mass);
            }
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            if (writer != null) {
                writer.close();
            }
        }
    }

    public void computeForces() {
        // Reset accelerations
        for (Particle p : particles) {
            p.ax = 0;
            p.ay = 0;
        }

        for (int i = 0; i < N; i++) {
            Particle pi = particles[i];
            for (int j = i + 1; j < N; j++) {
                Particle pj = particles[j];
                double dx = pj.x - pi.x;
                double dy = pj.y - pi.y;
                double r2 = dx * dx + dy * dy;
                double r = Math.sqrt(r2);
                if (r < 1e-2) r = 1e-2; // Avoid division by 0

                double fx = (A / r2 - B / (r2 * r2)) * (dx / r);
                double fy = (A / r2 - B / (r2 * r2)) * (dy / r);

                pi.ax += fx / pi.mass;
                pi.ay += fy / pi.mass;
                pj.ax -= fx / pj.mass;
                pj.ay -= fy / pj.mass;
            }
        }
    }

    public void verletIntegration() {
        for (Particle p : particles) {
            double ax_old = p.ax;
            double ay_old = p.ay;

            // Position update
            p.x += p.vx * dt + 0.5 * ax_old * dt * dt;
            p.y += p.vy * dt + 0.5 * ay_old * dt * dt;

            // Temporarily reset acceleration
            p.ax = 0;
            p.ay = 0;
        }

        computeForces(); // Update new accelerations

        for (Particle p : particles) {
            // Velocity update
            p.vx = (p.vx + 0.5 * (p.ax) * dt) * drag;
            p.vy = (p.vy + 0.5 * (p.ay) * dt) * drag;
        }
    }

    public void draw(DrawingPanel panel, Graphics g) {
        g.setColor(Color.RED);
        for (Particle p : particles) {
            int px = panel.xToPix(p.x - p.radius);
            int py = panel.yToPix(p.y + p.radius);
            int d = (int) (2 * panel.xToPix(p.radius) - panel.xToPix(0));
            g.drawOval(px, py - d, d, d); // Draw empty circle
        }
    }

    private void pause(int ms) {
        try {
            Thread.sleep(ms);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }
    
    public double[] computeBoundingBox() {
        double minX = Double.MAX_VALUE, maxX = -Double.MAX_VALUE;
        double minY = Double.MAX_VALUE, maxY = -Double.MAX_VALUE;

        for (Particle p : particles) {
            minX = Math.min(minX, p.x - p.radius);
            maxX = Math.max(maxX, p.x + p.radius);
            minY = Math.min(minY, p.y - p.radius);
            maxY = Math.max(maxY, p.y + p.radius);
        }

        double width = maxX - minX;
        double height = maxY - minY;
        double area = width * height;

        return new double[] { minX, maxX, minY, maxY, width, height, area };
    }

    
    public double computePotentialEnergy() {
        double totalEnergy = 0;

        for (int i = 0; i < N; i++) {
            Particle pi = particles[i];
            for (int j = i + 1; j < N; j++) {
                Particle pj = particles[j];
                double dx = pi.x - pj.x;
                double dy = pi.y - pj.y;
                double r2 = dx * dx + dy * dy;
                double r = Math.sqrt(r2);
                if (r < 1e-2) r = 1e-2;

                // Potential energy due to F1 and F2
                double energy = -A / r + B / (r * r);
                totalEnergy += energy;
            }
        }

        return totalEnergy;
    }

    

    public static void main(String[] args) {
    	PackingSimulator sim = new PackingSimulator();
        sim.initialize();
        sim.runSimulation();
    }
}
